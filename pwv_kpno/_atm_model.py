#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

#    This file is part of the pwv_kpno software package.
#
#    The pwv_kpno package is free software: you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    The pwv_kpno package is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
#    Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with pwv_kpno.  If not, see <http://www.gnu.org/licenses/>.

"""This code calculates atmospheric transmission curves based on cross-section
files generated by the LSST project's phosim code and the Beer-Lambert Law. It
is heavily based on code written by Wei Hu in numIntwei_new.py.

This code is not called by any end user functions. The models generated by
this code are already included in the pwv_kpno package. This code is included
for reference in future package development.
"""

import os

from astropy.table import Table
import numpy as np
import scipy.interpolate as interpolate

from ._settings import settings

__authors__ = ['Azalee Bostroem', 'Daniel Perrefort']
__copyright__ = 'Copyright 2016, Azalee Bostroem'
__editor__ = 'Daniel Perrefort'

__license__ = 'GPL V3'
__email__ = 'djperrefort@pitt.com'
__status__ = 'Development'

PHOSIM_DATA = settings._phosim_dir


def _load_cross_section(filename, x_fine):
    """Interpolate cross sections to fine wavelength grid

    Args:
        filename   (str): The path of a file with MODTRAN cross-sections
        x_fine (ndarray): An array of wavelengths in microns

    Returns:
        A 2d array of wavelengths (microns) and cross sections (cm^2)
    """

    cs = np.loadtxt(filename)
    y_func = interpolate.interp1d(cs[:, 0], cs[:, 1], kind='nearest')
    cs = np.transpose(np.array([x_fine, y_func(x_fine)]))
    return cs[:, :2]  # Only keep wavelength and cross section columns


def _construct_atm_sys(x_fine):
    """Create an array of interpolated cross sections for H20, O3, and O2

    Cross sections are interpolated for a given array of wavelengths

    Args:
        x_fine (ndarray): An array of wavelengths in microns

    Returns:
        Array of wavelengths (microns) and cross sections (cm^2) for each site
    """

    file_list = ['h2ocs.txt', 'o3cs.txt', 'o2cs.txt']
    h2o = _load_cross_section(os.path.join(PHOSIM_DATA, file_list[0]), x_fine)
    o3 = _load_cross_section(os.path.join(PHOSIM_DATA, file_list[1]), x_fine)
    o2 = _load_cross_section(os.path.join(PHOSIM_DATA, file_list[2]), x_fine)
    return np.array([h2o, o3, o2])


def _calculate_trans(x_fine, xlf_dict, pint_list):
    """Calculate the atmospheric transmission

    Args:
        x_fine   (ndarray): An array of wavelengths in microns
        xlf_dict    (dict): Values to be used to scale of p_int for different
                             levels of H2O, O2, and O3
        pint_list   (list): A list of initial p_int values

    Returns:
        An array of the H2O transmission for each wavelength in x_fine
    """

    # The following code allows for the modeling for atmospheric
    # effects due to O2, O3, and H2O. We only use the code H2O,
    # and comment out the rest for future reference
    """
    # formula, x_fine in um / 0.5um # aerosol tau
    AOD = xlf_dict['tau'].reshape((1, 1, 1, len(xlf_dict['tau']), 1, 1)) * \
          (x_fine/0.5) ** \
          (-xlf_dict['index'].reshape((1, 1, 1, 1, len(xlf_dict['index']), 1)))

    # aerosol tau
    tau_aero = -AOD

    # O2 transmission
    # + -cross-section*pint*tune?*x1f
    o2_len = len(xlf_dict['o2'])
    tau_aero_o2 = tau_aero + (-cross_sections[2, :, 1] * pint_list[2] *
                              xlf_dict['o2'].reshape((1, 1, o2_len, 1, 1, 1)))

    # X O3 transmission
    o3_len = len(xlf_dict['o3'])
    tau_aero_o3 = (-cross_sections[1, :, 1] * pint_list[1] *
                   xlf_dict['o3'].reshape((1, o3_len, 1, 1, 1, 1)))
    tau_aero_o2_o3 = tau_aero_o2 + tau_aero_o3

    # X H2o transmission
    h2o_len = len(xlf_dict['h2o'])
    tau_aero_h2o = (-cross_sections[0, :, 1] * pint_list[0] *
                    xlf_dict['h2o'].reshape((h2o_len, 1, 1, 1, 1, 1)))
    tau_aero_o2_o3_h2o = tau_aero_o2_o3 + tau_aero_h2o
    """

    # X H2o transmission
    cross_sections = _construct_atm_sys(x_fine)
    h2o_len = len(xlf_dict['h2o'])
    tau_h2o = (-cross_sections[0, :, 1] * pint_list[0] *
               xlf_dict['h2o'].reshape((h2o_len, 1, 1, 1, 1, 1)))

    return np.exp(tau_h2o)


def _generate_atm_model(wl_start, wl_end, dispersion, pint_list, xlf_dict):
    """Generate a model of atmospheric absorption

    Args:
        wl_start   (float): Starting wavelength of the model in angstroms
        wl_end     (float): Ending wavelength of the model in angstroms
        dispersion (float): Dispersion of the model (angstroms / pix)

    Returns:
        An array of wavelengths in Angstroms
        An array of the H2O transmission for each wavelength
    """

    num_pts = (wl_end - wl_start) / float(dispersion)
    x_fine_ang = np.linspace(wl_start, wl_end, num_pts)
    x_fine = x_fine_ang / 10000.  # Convert to microns
    atm_transmission = _calculate_trans(x_fine, xlf_dict, pint_list)
    return x_fine_ang, atm_transmission


def write_atm_models(output_dir):
    """Create an atmospheric model and write it to atm_model.csv

    Args:
        output_dir (str): The directory where atm_model.csv will be written
    """

    if not os.path.isdir(output_dir):
        os.makedirs(output_dir)

    NA = 6.02214129E23  # Avogadro's constant
    mol_cm_3 = NA / (18.0152 * 0.99997 * 10)  # Conversion to mol/cm^3

    # Integrated PWV
    # pint_h2o_norm=4.6331404996e+22  # 13.8595965622 mm
    pint_h2o_norm = 1.0  # Put all variation in xlf_dict['h2o']
    pint_o3_norm = 6.83830002464e+18  # 254 Dobson Units, 1 DU = 2.69e16
    pint_o2_norm = 4.51705326392e+24
    pint_list = [pint_h2o_norm, pint_o3_norm, pint_o2_norm]

    # If we decide to use the other elements in the atmospheric model then we
    # probably want to re-examine the values chosen here
    xlf_dict = {
        # 0.1 - 30.1 mm in units of mol/cm^3
        'h2o': np.arange(0.1, 31, 1) * mol_cm_3,

        'o3': np.array([1.0]),     # 20-50% DU
        'o2': np.array([1.]),      # 0.02%
        'tau': np.array([0.05]),   # aerosol tau
        'index': np.array([1.28])  # aerosol index
    }

    wl, atm_trans = _generate_atm_model(3000, 12000, 1, pint_list, xlf_dict)

    # Asserts that transmission is 100% for all wavelengths when PWV is 0
    out_table = Table(data=[wl, [1 for i in wl]], names=['wavelength', '00.0'])

    for model_num, model in enumerate(xlf_dict['h2o']):
        temp_table = Table(data=[wl, atm_trans[model_num, 0, 0, 0, 0, :]],
                           names=['wavelength', 'transmission'])

        pwv_level = model / NA * (18.0152 * 0.99997 * 10)
        pwv_as_str = '{:.1f}'.format(pwv_level).zfill(4)
        temp_table.rename_column('transmission', pwv_as_str)
        out_table.add_column(temp_table[pwv_as_str])

    out_table.write(os.path.join(output_dir, 'atm_model.csv'), overwrite=True)
